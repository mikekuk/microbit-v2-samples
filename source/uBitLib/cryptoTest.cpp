#include "cryptoTest.h"
#include "aes.h"
#include <string.h>
#include "MicroBit.h"
#include "MicroBitSender.h"

/*
This function implements the AES MonteCarlo Test. It is used to prove a succesfull implementation of the AES encryption scheme on a device.
As described in: https://csrc.nist.rip/encryption/aes/katmct/katmct.htm
*/
int monteCarlo()
{
    //Defining ciphers needed for the Monte Carlo Test
    #if AES_KEY_LEN == 32
        uint8_t cipher[16]= {0x1F, 0x67, 0x63, 0xDF, 0x80, 0x7A, 0x7E, 0x70, 0x96, 0x0D, 0x4C, 0xD3, 0x11, 0x8E, 0x60, 0x1A };
    #else
        uint8_t cipher[16]= {0xa0, 0x43, 0x77, 0xab, 0xe2, 0x59, 0xb0, 0xd0, 0xb5, 0xba, 0x2d, 0x40, 0xa5, 0x01, 0x97, 0x1b };
    #endif
    // Defining an array for the aes key and some contstans for loops and compare statements
    uint8_t key[AES_KEY_LEN], data[AES_BLK_LEN*2];
    int     i, j, equ;

    memset(key, 0, sizeof(key));
    memset(data,  0, sizeof(data));

    //Starting the Monte Carlo loop
    for(i=0;i<400;i++) {
        uBit.serial.printf("\r\n%d",i);
        for(j=0;j<10000;j++) {
            #if AES_KEY_LEN == 32
                memcpy(&data[16], data, 16);
            #endif
        
            #ifdef ASM
                uint8_t s[32];
                memcpy(s, data, 16);
                memcpy(&s[16], key, 16);
          
                aes_ecb(s);
                memcpy(data, s, 16);
            #else
                aes_ecb(key, data);
            #endif
        }
        #if AES_KEY_LEN == 32
            for(j=0;j<16;j++) key[j] ^= data[j+16];
            for(j=0;j<16;j++) key[j+16] ^= data[j];
        #else
            for(j=0;j<16;j++) key[j] ^= data[j];
        #endif
    }
    //Comparing the end result with the expected result:
    equ = (memcmp(data, cipher, 16)==0);

    return equ;
}
//END OF MONTE CARLO TEST

/*
This function encrypts four known plaintexts (in hex) with AES ecb and compares them to the expected outcome.
If correct the serial connection will display a succes message.
*/
int testEncryption()
{
    //Four example ecb keys
    uint8_t ecb_keys[4][32]={{0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c, 0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c},
                    {0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c, 0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c},
                    {0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c, 0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c},
                    {0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c, 0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c}
    };
    //Four known "plaintexts" (AEROHYDRODYNAMIC, CONTRAINDICATION, QUINTESSENTIALLY, UNSCIENTIFICALLY)
    uint8_t ecb_plain[4][16]={{0x41, 0x45, 0x52, 0x4f, 0x48, 0x59, 0x44, 0x52, 0x4f, 0x44, 0x59, 0x4e, 0x41, 0x4d, 0x49, 0x43},
                    {0x43,0x4f,0x4e,0x54,0x52,0x41,0x49,0x4e,0x44,0x49,0x43,0x41,0x54,0x49,0x4f,0x4e},
                    {0x51,0x55,0x49,0x4e,0x54,0x45,0x53,0x53,0x45,0x4e,0x54,0x49,0x41,0x4c,0x4c,0x59},
                    {0x55,0x4e,0x53,0x43,0x49,0x45,0x4e,0x54,0x49,0x46,0x49,0x43,0x41,0x4c,0x4c,0x59}
    };
    //Four known outcomes
    uint8_t ecb_cipher[4][16]={{0xdb, 0x0e, 0x6b, 0x2f, 0x9a, 0x19, 0xbb, 0x9e, 0x18, 0x38, 0xe1, 0x3d, 0x89, 0x6d, 0x71, 0x0f},
                    {0xdc, 0xb9, 0x05, 0xf5, 0x84, 0xe6, 0x2f, 0xd5, 0x19, 0xc2, 0x32, 0x21, 0x7b, 0x8d, 0x3f, 0x20},
                    {0xd7, 0x26, 0xa3, 0x17, 0x0b, 0x9c, 0xb4, 0xbf, 0x51, 0xed, 0xf6, 0xd3, 0x51, 0x72, 0x55, 0x64},
                    {0xeb, 0x61, 0x5a, 0x53, 0x3f, 0x1c, 0x05, 0xf7, 0xf0, 0xda, 0x78, 0xd4, 0x3d, 0x0f, 0xa8, 0x53}
    };
    
    int i, equ;
    uint8_t data[16], key[AES_KEY_LEN];
    
    // ecb tests
    for (i=0; i<4; i++) {
      memcpy(data, ecb_plain[i], 16);
      memcpy(key, ecb_keys[i], AES_KEY_LEN);
      
      #ifdef ASM
        uint8_t s[32];
        memcpy(s, data, 16);
        memcpy(&s[16], key, 16);
        
        aes_ecb(s);
        memcpy(data, s, 16);
      #else
        aes_ecb(key, data);
      #endif
      equ = (memcmp(data, ecb_cipher[i], 16) == 0);
      
      if (equ==0)
      {
        return 0;
      }
    }
    return 1;
}
//---END OF ENCRYPTION TEST---

